#ifndef _H_CRED_H
#define _H_CRED_H

#define _LINUX_CAPABILITY_U32S_3     2
#define _KERNEL_CAPABILITY_U32S    _LINUX_CAPABILITY_U32S_3

typedef struct kernel_cap_struct {
	__u32 cap[_KERNEL_CAPABILITY_U32S];
} kernel_cap_t;

#define CAP_TO_MASK(x)      (1U << ((x) & 31)) /* mask for indexed __u32 */
#define SECUREBITS_DEFAULT 0x00000000

#define CAP_CHECKPOINT_RESTORE	40
#define CAP_LAST_CAP         CAP_CHECKPOINT_RESTORE
#define CAP_LAST_U32_VALID_MASK		(CAP_TO_MASK(CAP_LAST_CAP + 1) -1)

# define CAP_EMPTY_SET    ((kernel_cap_t){{ 0, 0 }})
# define CAP_FULL_SET     ((kernel_cap_t){{ ~0, CAP_LAST_U32_VALID_MASK }})

struct cred {
	//atomic_t	usage;
	unsigned int		uid;		/* real UID of the task */
	unsigned int		gid;		/* real GID of the task */
	unsigned int		suid;		/* saved UID of the task */
	unsigned int		sgid;		/* saved GID of the task */
	unsigned int		euid;		/* effective UID of the task */
	unsigned int		egid;		/* effective GID of the task */
	unsigned int		fsuid;		/* UID for VFS ops */
	unsigned int		fsgid;		/* GID for VFS ops */
	unsigned	securebits;	/* SUID-less security management */
	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
	kernel_cap_t	cap_permitted;	/* caps we're permitted */
	kernel_cap_t	cap_effective;	/* caps we can actually use */
	kernel_cap_t	cap_bset;	/* capability bounding set */
	kernel_cap_t	cap_ambient;	/* Ambient capability set */
};

#endif